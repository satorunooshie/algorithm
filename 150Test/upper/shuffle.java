/*
 * トランプをシャッフルするメソッドの実装
 * ただし52!通りの順列が等確率になるような完璧シャッフルである必要がある
 * 完璧な乱数を生成するメソッドが与えられていると仮定する
 */
/*
 * ブルートフォースの考え方
 * ランダムにトランプを選び新しい山にトランプを乗せる
 * 実際にはトランプの山は配列として扱うので選んだ場所をマークする必要がある
 * 元の山(4を選ぶ場合) 1 2 3 4 5
 * 元の配列で選んだ場所に洗濯済みという意味で-をつける
 * -をつけた場所は今後選ばないようにする
 *  シャッフルした山(選択後) 4 ? ? ? ?
 *  元の山(選択後) 1 2 3 - 5
 *  難しいのは-印をつけた箇所が再度選ばれないようにするにはどうすればいいかという問題
 *  一つの方法は今選んだ4をトランプの先頭と入れ替えること
 *  シャッフルした山 4 ? ? ? ?
 *  元の山 - 1 2 3 5
 *  ランダムに選んだ要素をシャッフルした山の二番目に移動する
 *  元の山はその要素と前から二番目の要素と入れ替えて印をつける
 *  シャッフルした山(3選択後) 4 3 ? ? ?
 *  元の山 - - 2 1 5
 *  このようにするとk番目が選択済みのようにするのに比べて
 *  最初のk枚のトランプが選択済みというふうに非常にわかりやすいアルゴリズムになる
 *  またこのアルゴリズムは元の大和シャッフルした山を一つにまとめることで
 *  最適化することもできる
 *  元の山(4の選択前) 1 2 3 4 5
 *  1から5の要素をランダムに選びそれを1と入れ替える
 *  例えば4を選んだとすると4の部分に1が入り、配列の一番目の要素は選択済みとなる
 *  元の山(4の選択後) 4 2 3 1 5
 *  一番目の要素は選択済みなので次にランダムで選んだ要素は
 *  二番目の要素と入れ替える
 *  例えば3を選んだとすると
 *  元の山(3の選択後) 4 3 2 1 5
 *  これを繰り返し、0からn-1の全てのiについてランダムに選んだ
 *  要素j(j>=i, j<n)とiを入れ替えることを繰り返す
 */
public void shuffleArray(int[] cards) {
    int temp, index;
    for (int i = 0; i < cards.length; i++) {
        /*
         * インデックスが0からi-1までのカードは既に選ばれているので前方に移動している
         * 従って次はi以上のインデックスのカードをランダムに選ぶ
         */
        index = (int)(Math.randam() * (cards.length - 1)) + i;
        temp = cards[i];
        cards[i] = cards[index];
        cards[index] = temp;
    }
}
