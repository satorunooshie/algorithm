/* 整数配列が与えられた時、連続する要素の合計の最大値を求めるメソッド */
/*
   2 3 -8 -1 2 4 -2 3
   連続する負の数、または正の数の一部だけを含んだ並びが最大にならない
   それは連続する負の数の一部分だけを含むと不必要に合計値を減らすだけなので、その部分の負の数は全く含まないようにするから。
   同様に全体を足した方が合計より大きくなるので連続する正の数の一部分だけを含むのはおかしい
   整理するために配列を負の数と正の数交互に並ぶようにまとめると
   5 -9 6 -2 3
   このように見ると{5, -9}を選ぶなら{5}だけを選んだ方がいいです
   負の数を選びたい場合は負の数の前後にある正の数によってそれぞれとの和が負にならないときのみ
   配列の最初から始めて段階的に考えてみる
   まず要素5に注目するとその時点ではそれが最大値になるので最大値を保持するmaxSumに5をセットし
   その時点での合計値currentSumも5になる
   さらに次の要素-9ではcurrentSumに-9を加えるので-4となり、負の数になる
   従って5から-9の連続要素は不要となるのでcurrentSumの値を0にリセットする
   次は要素6の部分に注目する
   6はmaxSumの5より大きいので更新し、currentSumも6にセットする
   次の要素-2をcurrentSumに加えると4になり、これは次の要素へつなぐことでより大きな値になる可能性があるので
   currentSumを4、部分配列を{6, -2}とした状態で次の要素を見ていく
   このときmaxSumの値は更新されない
   最後に要素3ではcurrentSum(4)に3を加えると7になり、maxSumが更新される
   従って合計が最大になる部分配列は{6, -2, 3}となる

   もし配列の要素が全て負の場合、例えば{-3, -10, -5}を考えてみると最大値は
   配列が空ではいけないと仮定した場合-3
   配列が空でもいい場合0
   エラーとして扱う場合MINIMUM_INT
   が考えられる
*/
public static int getMaxSum(int[] a) {
    int maxsum = 0;
    int sum = 0;
    for (int i = 0; i < a.length; i++) {
        sum += a[i];
        if (maxsum < sum) {
            maxsum = sum;
        } else if (sum < 0) {
            sum = 0;
        }
    }
    return maxsum;
}
