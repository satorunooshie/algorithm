/* 0から4までの乱数を生成するrand5()が与えられたとき、0から6までの乱数を生成するrand7()の実装 */
//0から6の値が全て1/7の確率で返す必要がある
//呼び出し回数調整法
//0から9の数を生成して7の剰余を返す
int rand7() {
    int v = rand5() + rand5();
    return v % 7;
}
/*
   等確率で乱数を生成することができない
   P(rand7() = 6) = 1/5^i + 1/5^j ... + 1/5^m
   この確率が1/7になったとき関数が正しく動作します
   しかし5と7が互いに素数であるため、5の累乗の逆数で1/7にはできない
*/
//呼び出し回数非決定法
/*
   whileループを使えばかなり簡単に解決することができる
   均等に出現しそうな範囲かつ、要素が少なくとも7個はあるように区切って値を生成すれば良い
   こうすると発生させた値をちょうど7の倍数で区切り、余分なところを捨てることができる
   あとはその値に対する7での剰余を返すだけで0から6を等確率で発生させることができる
   次のコードは5*rand5()*rand5()として0から24までの値を生成し、
   0から3の比重が大きくなってしまうので21から24の値は破棄します
   最後にこの値の剰余を計算して0から6までの値を均等に返すコードにする
   この方法では余計な値の破棄を行うため、rand5()の呼び出し回数は保証できない
*/
public static int rand7() {
    while (true) {
        int num = 5 * rand5() + rand5();
        if (num < 21) {
            return num % 7;
        }
    }
}
//2*rand5()+rand5()を用いると発生する確率は均等ではなくなる
//6=2*1+4,2*2+2 //0=2*0+0
//rand5を用いて均等に値を得る方法はあるが複雑になる
public int rand7() {
    while (true) {
        int r1 = 2 * rand5(); //0-9の偶数
        int r2 = rand5(); //後で0-1を作成するのに用いる
        if (r2 != 4) { //r2の余分な部分を捨てる
            int rand1 = r2 % 2; //0,1を作成
            int num = r1 + rand1; //0-9の範囲
            if (num < 7) {
                return num;
            }
        }
    }
}

